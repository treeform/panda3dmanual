<h2>The Shader Generator</h2>

As of version 1.5.0, panda supports several new features:

* per-pixel lighting
* normal mapping
* gloss mapping
* glow mapping
* high-dynamic range rendering
* cartoon shading

It's not that these things weren't possible before: they were.  But previously, you had to write shaders to accomplish these things.  This is no longer necessary.  As of version 1.5.0, all that has to happen is for the artist
to apply a normal map, gloss map, or glow map in the 3D modeling program.
Then, the programmer gives permission for shader generation, and Panda3D
handles the rest.

A few of these features do require minimal involvement from the programmer:
for instance, high-dynamic range rendering requires the programmer to choose a tone-mapping operator from a small set of options.  But that's it: the amount of work required of the programmer is vastly less than before.

Many of these features are complementary with [[Common Image Filters|image postprocessing operations]], some of which are now nearly-automatic as well.
For example, HDR combines very nicely with the bloom filter, and cartoon
shading goes very well with cartoon inking.

Individually, these features are not documented in this chapter of the manual.  Instead, they're documented in the portion of the manual where they make the
most sense.  For example, normal mapping, gloss mapping, and glow mapping
are all documented in the section on [[Texturing]].  HDR and cartoon shading
are documented under Render Attributes in the subsection on [[Light Ramps]].  

However, to enable any of these features, you need to tell Panda3D that it's OK to automatically generate shaders and send them to the video card.  The call to do this is:

[python]<code python>
nodepath.setShaderAuto()
</code>[/python]
[cxx]<code cxx>
nodepath.set_shader_auto();
</code>[/cxx]

If you don't do this, none of the features listed above will have any effect.  Panda will simply ignore normal maps, HDR, and so forth if shader generation is not enabled.  It would be reasonable to enable shader generation for the entire game, using this call:

[python]<code python>
render.setShaderAuto()
</code>[/python]
[cxx]<code cxx>
window->get_render().set_shader_auto();
</code>[/cxx]

<h2>Sample Programs</h2>

Three of the sample programs demonstrate the shader generator in action:

* [[Sample Programs: Cartoon Shader]]
* [[Sample Programs: Glow Filter]]
* [[Sample Programs: Normal Mapping]]

In each case, the sample program provides two versions: Basic and Advanced.
The Basic version relies on the shader generator to make everything automatic.
The Advanced version involves writing shaders explicitly.

<h2>Per-Pixel Lighting</h2>

Simply turning on <code>[func]setShaderAuto[/func]</code> causes one immediate change:
all lighting calculations are done per-pixel instead of per-vertex.
This means that models do not have to be highly tesselated in order to
get nice-looking spotlights or specular highlights.

Of course, the real magic of <code>[func]setShaderAuto[/func]</code> is that it enables
you to use powerful features like normal maps and the like.

<h2>Known Limitations</h2>

The shader generator replaces the fixed-function pipeline with a shader.  To make this work, we have to duplicate the functionality of the <i>entire</i> fixed function pipeline.  That's a lot of stuff.  We haven't implemented all of it yet.  Here's what's supported: (as of version 1.7.0)

<ul>
<li>flat colors, vertex colors and color scales
<li>lighting
<li>normal maps
<li>gloss maps
<li>glow maps
<li>materials, but not updates to materials
<li>1D, 2D, 3D, cube textures
<li>most texture stage and combine modes
<li>light ramps (for cartoon shading)
<li>some texgen modes
<li>texmatrix
</ul>

Here's what's known to be missing:

<ul>
<li>some texgen modes
<li>fog
</ul>

These functions are high on the list of priorities, and will probably be coming sometime in the next month or so.

<h2>How the Shader Generator Works</h2>

When panda goes to render something marked <code>[func]setShaderAuto[/func]</code>, it synthesizes a shader to render that object.  In order to generate the shader, it examines all the attributes of the object: the lights, the material, the fog setting, the color, the vertex colors... almost everything.  It takes into account all of these factors when generating the shader.  For instance, if the object has a material attrib, then material color support is inserted into the shader.  If the object has lights, then lighting calculations are inserted into the shader.  If the object has vertex colors, then the shader is made to use those.

<h2>Caching and the Shader Generator</h2>

If two objects are rendered using the same RenderState (ie, the exact same attributes), then the shader is only generated once.  But even a single change to the RenderState will cause the shader to be regenerated.  This is not entirely cheap.  Making changes to the RenderState of an object should be avoided when shader generation is enabled, because this necessitates regeneration of the shader.  

A few alterations don't count as RenderState modifications: in particular, changing the positions and colors of the lights doesn't count as a change to the RenderState, and therefore, does not require shader regeneration.  This can be useful: if you just want to tint an object, apply a light to it then change the color of the light.

There is a second level of caching.  If the system generates a shader, it will then compare that shader to the other shaders it has generated previously.  If it matches a previously-generated shader, it will not need to compile the shader again.

So, to save the full cost, use the same RenderState.  To save most of the cost, use two RenderStates that are similar.  By "similar," I mean having the same general structure: ie, two models that both have a texture and a normal map, and both have no vertex colors and neither has a material applied.

<h2>Combining Automatic Shaders with Manual Shaders</h2>

Sometimes, you will want to write most of a game using panda's automatic shader generation abilitites, but you'll want to use a few of your own shaders.  A typical example would be a scene with some houses, trees, and a pond.  You can probably do the houses and trees using panda's built-in abilities.  However, Panda doesn't contain anything that particularly looks like pond-water: for that, you'll probably need to write your own shader.

When you use <code>render.[func]setShaderAuto[/func]()</code>, that propagates down the scene  graph just like any other render attribute.  If you assign a specific shader to a node using <code>nodepath.[func]setShader[/func](myshader)</code>, that overrides any shader assignment propagated down from above, including an <i>Auto</i> shader assignment from above.  So that means it is easy, in the example above, to enable auto shader generation for the scene as a whole, and then override that at the pond-nodepath.

<h2>Creating your own Shader Generator</h2>

We anticipate that people who are writing full-fledged commercial games using
Panda3D might want to write their own shader generators.  In this
way, you can get any effect you imagine without having to give up the
convenience and elegance of being able to simply apply a normal map
or a gloss map to a model, and having it "just work."

To create your own shader generator, you will need to delve into Panda3D's C++ code.  Class ShaderGenerator is meant to be subclassed, and a hook function is provided to enable you to turn on your own generator.

<h2>Retrieving the generated shader</h2>

In case you want to use the shader generator manually, for example when you want to grab the output of the shaders it generates, you can get a handle to the default [http://panda3d.org/apiref.php?page=ShaderGenerator ShaderGenerator] like this:
<pre class="codeblock">from pandac.PandaModules import ShaderGenerator
sg = ShaderGenerator.getDefault()
shaderAttrib = sg.synthesizeShader(renderstate)</pre>
The synthesizeShader method generates a shader based on the given renderstate. (For example, you could specify <code>render.getState()</code> as parameter.) The function returns a [http://panda3d.org/apiref.php?page=ShaderAttrib ShaderAttrib] instance on which you can retrieve the shader using the <code>getShader()</code> method. For example, if you want to print out the generated shader for <code>render</code>, you could do:
<pre class="codeblock">sg = ShaderGenerator.getDefault()
shader = sg.synthesizeShader(render.getState()).getShader()
print shader.getText()</pre>
Note, however, that this does not work for postprocessing effects, since these are handled by a different class, and also require additional setup like buffers.
